==============================================================================
Common library methods                                             *firvish.lib*

lib.exit_visual_mode()                            *firvish.lib.exit_visual_mode*
    Exit visual mode
    Required when getting a visual selection in order for the registers
    to get correctly set.


lib.get_cursor_line()                              *firvish.lib.get_cursor_line*
    Get the line under the cursor in the current buffer

    Returns: ~
        (string)


lib.get_selected_lines()                        *firvish.lib.get_selected_lines*
    Get the visually selected lines in the current buffer

    Returns: ~
        (string[])


lib.get_visual_selection()                    *firvish.lib.get_visual_selection*
    Get the visual selection range
    @return number, number


lib.now()                                                      *firvish.lib.now*
    Format the current datetime in H:M:S format

    Returns: ~
        (string|osdate)


==============================================================================
The errorlist api                                        *firvish.lib.errorlist*

                                              *firvish.lib.errorlist.from_lines*
errorlist.from_lines({what}, {lines}, {opts?})
    Create an errorlist from a table of lines.

    Parameters: ~
        {what}   (string)    the type of errorlist to open; [quickfix|loclist]
        {lines}  (string[])  lines to send to the errorlist
        {opts?}  (table)


                                           *firvish.lib.errorlist.from_buflines*
errorlist.from_buflines({what}, {buffer}, {opts?})
    Create an errorlist from a buffer.

    Parameters: ~
        {what}    (string)  the type of errorlist to open; [quickfix|loclist]
        {buffer}  (Buffer)  buffer to get quickfix lines from
        {opts?}   (table)   see |setqflist-what|


                                           *firvish.lib.errorlist.from_bufrange*
errorlist.from_bufrange({what}, {buffer}, {line1}, {line2}, {opts?})
    Create an errorlist from a range of buffer lines.

    Parameters: ~
        {what}    (string)  the type of errorlist to open; [quickfix|loclist]
        {buffer}  (Buffer)  buffer to get quickfix lines from
        {line1}   (number)  line range start index
        {line2}   (number)  line range end index
        {opts?}   (table)   see |setqflist-what|


                                         *firvish.lib.errorlist.from_job_output*
errorlist.from_job_output({what}, {job}, {opts?})
    Create an errorlist from a Job's output.

    Parameters: ~
        {what}   (string)  the type of errorlist to open; [quickfix|loclist]
        {job}    (Job)     job to get quickfix lines from
        {opts?}  (table)   see |setqflist-what|


==============================================================================
The generator api                                       *firvish.lib.generators*

generators.sorted_pairs()                  *firvish.lib.generators.sorted_pairs*
    Sorted version of |pairs()|


==============================================================================
The jobs api                                                  *firvish.lib.jobs*

StartJobOpts                                     *firvish.lib.jobs.StartJobOpts*

    Fields: ~
        {command}     (string)
        {args}        (string[])
        {cwd?}        (string)
        {filetype?}   (string)
        {title?}      (string)
        {bopen?}      (boolean|OpenBufferOpts)
        {eopen?}      (boolean)
        {errorlist?}  (string)
        {efm?}        (string|string[])
        {no_stdout?}  (boolean)
        {no_stderr?}  (boolean)
        {on_exit?}    (function)
        {keep?}       (boolean)


OpenBufferOpts                                 *firvish.lib.jobs.OpenBufferOpts*

    Fields: ~
        {headers?}  (boolean)
        {how?}      (string)


jobs.start_job({opts})                              *firvish.lib.jobs.start_job*
    Start a job

    Parameters: ~
        {opts}  (StartJobOpts)

    Returns: ~
        (Job)


jobs.get_joblist({filter?})                       *firvish.lib.jobs.get_joblist*
    Get the current joblist

    Parameters: ~
        {filter?}  (Filter)  used to return a subset of jobs matching the given filter

    Returns: ~
        (JobList)


==============================================================================
Common library types                                             *firvish.types*

                                                          *firvish.types.buffer*
Buffer                                                           *Buffer.Buffer*

    Fields: ~
        {bufnr}  (number)    the underlying buffer handle
        {lines}  (string[])  the buffer lines


Buffer:new({bufnr}, {name?})                                        *Buffer:new*
    Create a new buffer
    If name is provided, will rename the buffer via |nvim_buf_set_name|

    Parameters: ~
        {bufnr}  (number)  the underlying buffer handle
        {name?}  (string)  used to rename the buffer

    Returns: ~
        (Buffer)


Buffer:listed()                                                  *Buffer:listed*
    Whether a buffer is buflisted or not

    Returns: ~
        (boolean)


Buffer:loaded()                                                  *Buffer:loaded*
    Whether a buffer is |nvim_buf_is_loaded| or not

    Returns: ~
        (boolean)


Buffer:modified()                                              *Buffer:modified*
    Whether a buffer is |'modified'| or not

    Returns: ~
        (boolean)


Buffer:valid()                                                    *Buffer:valid*
    Whether a buffer is |nvim_buf_is_valid| or not

    Returns: ~
        (boolean)


Buffer:visible()                                                *Buffer:visible*
    Whether a buffer is visible or not
    That is, whether |bufwinnr()| ~= -1

    Returns: ~
        (boolean)


Buffer:name()                                                      *Buffer:name*
    Shorthand to |fnamemodify()| the |bufname()| of this buffer

    Returns: ~
        (string)


Buffer:filetype()                                              *Buffer:filetype*
    Gets the buffer's |'filetype'|

    Returns: ~
        (string)


Buffer:winnr()                                                    *Buffer:winnr*
    Gets the buffer's |bufwinnr()|

    Returns: ~
        (number)


Buffer:create_autocmd()                                  *Buffer:create_autocmd*
    Create a buffer-local auto-command
    Shorthand for |nvim_create_autocmd()| with the buffer option set to this buffer


Buffer:on_buf_delete({f})                                 *Buffer:on_buf_delete*
    Create an autocmd, triggered on |BufDelete| and |BufWipeout|.

    Parameters: ~
        {f}  (function)  the callback passed to |nvim_create_autocmd()|


Buffer:create_user_command()                        *Buffer:create_user_command*
    Create a buffer-local user command
    Shorthand for |nvim_buf_create_user_command()| with bufnr preset


Buffer:get_option()                                          *Buffer:get_option*
    Shorthand for |nvim_buf_get_option()| with bufnr preset


Buffer:set_option()                                          *Buffer:set_option*
    Shorthand for |nvim_buf_set_option()| with bufnr preset


Buffer:set_options()                                        *Buffer:set_options*
    Set multiple buffer-local options at once


Buffer:is_same()                                                *Buffer:is_same*
    Checks whether this buffer points to the same bufnr as other

    Returns: ~
        (boolean)


Buffer:line()                                                      *Buffer:line*
    Shorthand for |getbufline()| with bufnr preset, but only returns a single line


Buffer:get_lines()                                            *Buffer:get_lines*

    Returns: ~
        (string[])

    See: ~
        |vim.api.nvim_buf_get_lines|


Buffer:append()                                                  *Buffer:append*
    Appends a line to this buffer

    Returns: ~
        (Buffer)


Buffer:set_lines()                                            *Buffer:set_lines*
    Shorthand for |nvim_buf_set_lines()|, overwriting the whole buffer contents


                                                           *Buffer:filter_lines*
Buffer:filter_lines({line1}, {line2}, {pattern}, {matching?}, {yank?})
    Filter a buffer's lines, like |:g|

    Parameters: ~
        {line1}      (number)   line range start
        {line2}      (number)   line range end
        {pattern}    (string)   regex
        {matching?}  (boolean)  when true, remove lines matching the pattern, else remove lines NOT matching the pattern
        {yank?}      (boolean)  when true, uses the `:d` command, else uses the `:d_` command

    Usage: ~
>lua
        buffer:filter_lines(0, -1, "lua", true) -- Only lines without "lua" in them
<


Buffer:open()                                                      *Buffer:open*

    Returns: ~
        (Buffer)


Buffer:set_keymap()                                          *Buffer:set_keymap*
    Shorthand for |vim.keymap.set()| with the buffer option preset


Buffer:apply_keymaps()                                    *Buffer:apply_keymaps*
    Set mode mappings in this buffer
    Like set_keymap() but accepts a table where the lefthand side is the mode
    and the righthand side is table of mappings

    Usage: ~
>lua

        local buffer = Buffer:new(...)
        buffer:set_keymaps {
          n = {
            -- <rhs> can be a function
            ["<CR>"] = function()
              ...
            end,
            -- or a table with a function as its first element
            -- and a table as its second (to specify additional opts)
            ["<C-y>"] = {
              function()
                ...
              end,
              { desc = "Do something with <C-y>" },
            },
          },
        }

<


Buffer:call({cmd})                                                 *Buffer:call*
    Execute an Ex command with this buffer as temporary current buffer

    Parameters: ~
        {cmd}  (string)  anything suitable for |nvim_command()|


Buffer:bdelete()                                                *Buffer:bdelete*


Buffer:rename()                                                  *Buffer:rename*
    Shorthand for |nvim_buf_set_name()| with bufnr preset


ErrorList                                                  *ErrorList.ErrorList*

    Fields: ~
        {action}     (string)
        {context}    (table)
        {efm}        (string)
        {errorlist}  (string)
        {title}      (string)


ErrorList:new({errorlist}, {opts})                               *ErrorList:new*
    Construct a new errorlist (quickfix or loclist)

    Parameters: ~
        {errorlist}  (string)  The type of errorlist to create, must be one of [quickfix, loclist].
        {opts}       (table)   See vim.fn.setqflist and vim.fn.setloclist

    See: ~
        |vim.fn.setqflist|
        |vim.fn.setloclist|


                                                      *ErrorList:from_buf_lines*
ErrorList:from_buf_lines({errorlist}, {buffer}, {line1}, {line2}, {opts})
    For the given buffer, send the specified range of lines to an errorlist (quickfix or loclist).

    Parameters: ~
        {errorlist}  (string)
        {buffer}     (Buffer)
        {line1}      (number)
        {line2}      (number)
        {opts}       (table)


ErrorList:set()                                                  *ErrorList:set*


ErrorList:set_()                                                *ErrorList:set_*


ErrorList:open()                                                *ErrorList:open*


ErrorList:close()                                              *ErrorList:close*


==============================================================================
                                                                *firvish.filter*

                                                               *firvish-filters*
Filters can be used in several contexts to modify what data is being returned to you (e.g. from
an API call) or what is being shown in a Firvish buffer (e.g. the |firvish-buffers| buffer).

Filters can be composed using `+` and `-`.

>
local is_listed = Filter:new(function(bufnr)
  return vim.fn.buflisted(bufnr)
end)

local is_modified = Filter:new(function(bufnr)
  return vim.bo[bufnr].modified
end)

local is_listed_and_modified = is_listed + is_modified
local is_listed_not_modified = is_listed - is_modified

local bufnr_listed_modified = 42
local bufnr_listed_not_modified = 13
assert(is_listed_and_modified(bufnr_listed_modified) == true)
assert(is_listed_not_modified(bufnr_listed_not_modified) == true)
<

Filter:new({predicate})                                     *firvish.filter:new*
    Constructs a new Filter from the given predicate function

    Parameters: ~
        {predicate}  (function)

    Returns: ~
        (Filter)

    Usage: ~
>lua
        local filter = Filter:new(function(...)
          return true
        end)
<


JobHandle                                                    *JobList.JobHandle*

    Type: ~
        number


JobList                                                        *JobList.JobList*

    Fields: ~
        {jobs}      (Job[])
        {previews}  (JobPreview[])


JobList:new()                                                      *JobList:new*


JobList:add({job}, {preview})                                      *JobList:add*

    Parameters: ~
        {job}      (Job)
        {preview}  (JobPreview)


JobList:at()                                                        *JobList:at*


JobList:remove({idx})                                           *JobList:remove*

    Parameters: ~
        {idx}  (number)


JobList:iter()                                                    *JobList:iter*


JobList:len()                                                      *JobList:len*


JobList:count()                                                  *JobList:count*


JobList:lines()                                                  *JobList:lines*


JobList:filter()                                                *JobList:filter*


Job                                                                    *Job.Job*

    Fields: ~
        {job}          (Handle)
        {data}         (string[])
        {stdout_}      (string[])
        {stderr_}      (string[])
        {errorformat}  (string)
        {running}      (boolean)
        {exit_code}    (number)
        {start_time_}  (osdate)
        {end_time_}    (osdate)


Job:new()                                                              *Job:new*


Job:new_()                                                            *Job:new_*


Job:start()                                                          *Job:start*


Job:stop()                                                            *Job:stop*


Job:lines()                                                          *Job:lines*


Job:stdout()                                                        *Job:stdout*


Job:stderr()                                                        *Job:stderr*


Job:start_time()                                                *Job:start_time*


Job:end_time()                                                    *Job:end_time*


JobPreview                                               *JobPreview.JobPreview*

    Fields: ~
        {job}     (Job)
        {buffer}  (Buffer)
        {opts}    (table)


JobPreview:new()                                                *JobPreview:new*


JobPreview:open()                                              *JobPreview:open*


JobPreview:line()                                              *JobPreview:line*


vim:tw=78:ts=8:noet:ft=help:norl:
